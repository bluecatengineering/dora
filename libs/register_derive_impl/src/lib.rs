#![allow(clippy::large_enum_variant)]
extern crate proc_macro;

use proc_macro2::{Span, TokenStream};
use quote::quote;
use syn::{
    parse::{Parse, ParseStream},
    parse_macro_input, parse_quote,
    punctuated::Punctuated,
    spanned::Spanned,
    DeriveInput, Ident, Token,
};

#[proc_macro_derive(Register, attributes(register))]
pub fn register_macro(input: proc_macro::TokenStream) -> proc_macro::TokenStream {
    let input = parse_macro_input!(input as DeriveInput);

    proc_macro::TokenStream::from(impl_register(input))
}

fn impl_register(input: DeriveInput) -> TokenStream {
    let name = &input.ident;
    let ident_str = name.to_string();
    let attrs = &input.attrs;

    let registered = match attrs
        .iter()
        .filter(|attr| attr.path.is_ident("register") && !is_doc_attr(attr))
        .map(|attr| attr.parse_args_with(RegisterVariant::parse))
        .collect::<Result<Vec<RegisterVariant>, _>>()
    {
        Ok(msgs) => msgs,
        Err(err) => {
            // let message = "#[derive(IntoPrimitive)] and #[num_enum(u8)] requires a variant marked with `#[num_enum(catch_all)`";
            return syn::Error::new(Span::call_site(), err).to_compile_error();
        }
    };
    // dbg!(&registered);
    let msg_types = registered.iter().filter_map(|reg| match reg {
        RegisterVariant::Msg(d) => Some(d.clone()),
        _ => None,
    });

    let generics = add_trait_bounds(input.generics);
    let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();

    let reg = registered
        .iter()
        .filter_map(|reg| match reg {
            RegisterVariant::Plugin(d) => Some(d.clone()),
            _ => None,
        })
        .collect::<Vec<Deps>>();
    let reg_len = reg.len();
    let dependencies = reg
        .into_iter()
        .enumerate()
        .map(|(i, dep)| {
            let method: Ident = Ident::new("plugin", Span::call_site());
            let dependencies = dep
                .dependencies
                .iter()
                .map(|path| {
                    quote! {
                        std::any::TypeId::of::<#path>()
                    }
                })
                .collect::<Vec<_>>();
            // we dont want to clone the last item
            let new_this = if i == reg_len - 1 {
                // `this` comes from the scope created in the dora_core::Register block
                // at the end of impl_register
                quote! { this }
            } else {
                quote! { Arc::clone(&this) }
            };

            if dependencies.is_empty() {
                quote! {
                    srv.#method::<Self, _>(#new_this);
                }
            } else {
                // only call the _order method if there are dependencies
                let method = Ident::new(&format!("{}_order", method), Span::call_site());
                quote! {
                    srv.#method::<Self, _>(#new_this, &[ #(#dependencies),* ]);
                }
            }
        })
        .collect::<Vec<_>>();

    // println!("{:#?}", msg_params);
    // let msg_param = msg_params.msg_type;
    // let storage_param = msg_params.1;
    // println!("{:#?}", impl_generics);
    // println!("{:#?}", ty_generics);
    msg_types.into_iter().map(|msg_type| {
        let msg_param = msg_type.msg;
        quote! {
            #[automatically_derived]
            impl #impl_generics dora_core::Register<#msg_param> for #name #ty_generics #where_clause {
                fn register(self, srv: &mut dora_core::Server<#msg_param>) {
                    info!("{} plugin registered", #ident_str);
                    let this = std::sync::Arc::new(self);
                    #(#dependencies)*
                }
            }
        }
    }).collect()
}

// Add a bound `T: Send + Sync + 'static` to every type parameter T.
fn add_trait_bounds(mut generics: syn::Generics) -> syn::Generics {
    // add send + sync + 'static bounds
    for param in &mut generics.params {
        if let syn::GenericParam::Type(ref mut type_param) = *param {
            type_param.bounds.push(parse_quote!(Send));
            type_param.bounds.push(parse_quote!(Sync));
            type_param.bounds.push(parse_quote!('static));
        }
    }
    generics
}

// Whether the attribute is one like `#[<name> ...]`
fn is_matching_attr(name: &str, attr: &syn::Attribute) -> bool {
    attr.path.segments.len() == 1 && attr.path.segments[0].ident == name
}

/// Checks for `#[doc ...]`, which is generated by doc comments.
fn is_doc_attr(attr: &syn::Attribute) -> bool {
    is_matching_attr("doc", attr)
}

#[derive(Debug, Clone)]
struct Deps {
    _keyword: kw::plugin,
    // method: syn::Ident,
    dependencies: Punctuated<syn::Type, Token![,]>,
}

impl syn::parse::Parse for Deps {
    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {
        let content;
        let _keyword = input.parse()?;

        syn::parenthesized!(content in input);
        let deps = content.parse_terminated(syn::Type::parse)?;

        Ok(Self {
            _keyword,
            // method,
            dependencies: deps,
        })
    }
}
impl Spanned for Deps {
    fn span(&self) -> Span {
        self._keyword.span()
    }
}

mod kw {
    syn::custom_keyword!(msg);
    syn::custom_keyword!(plugin);
}

#[derive(Debug, Clone)]
enum RegisterVariant {
    Msg(MsgVariant),
    Plugin(Deps),
}

impl Parse for RegisterVariant {
    fn parse(input: ParseStream<'_>) -> syn::Result<Self> {
        let lookahead = input.lookahead1();
        if lookahead.peek(kw::msg) {
            input.parse().map(Self::Msg)
        } else if lookahead.peek(kw::plugin) {
            input.parse().map(Self::Plugin)
        } else {
            Err(lookahead.error())
        }
    }
}

#[derive(Debug, Clone)]
struct MsgVariant {
    _keyword: kw::msg,
    msg: syn::Type,
}

impl Parse for MsgVariant {
    fn parse(input: ParseStream) -> syn::Result<Self> {
        let content;
        let _keyword = input.parse()?;
        syn::parenthesized!(content in input);
        let msg = content.parse()?;

        Ok(Self { _keyword, msg })
    }
}

impl Spanned for MsgVariant {
    fn span(&self) -> Span {
        self._keyword.span()
    }
}
